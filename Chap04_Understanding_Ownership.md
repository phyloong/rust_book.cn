# 理解所有权

所有权是 Rust 最独特的特性，深深影响了语言的其他部分。它使得 Rust 在没有垃圾回收的情况下，保证内存安全，所以理解所有权的工作方式非常重要。在本章中，我们将讨论所有权以及相关的特性：借用（borrowing），切片（slice），以及 Rust 如何在内存中布局数据。

## 什么是所有权？

所有权是一系列规则，决定了 Rust 程序如何管理内存。所有程序在运行时都必须管理它们使用电脑内存的方式。一些语言有垃圾回收，程序运行时定期查找不再被使用的内存；其它语言中，程序员必须显式分配和释放内存。Rust 使用第三种方法：内存由包含一系列编译器能够检查的规则的所有权系统管理。如果任一规则被违反，程序就无法编译。所有权特性不会在程序运行时拖慢速度。

因为对许多程序员来说，所有权是一个新概念，他需要一些时间来适应。好消息是你对 Rust 和所有权系统的规则越有经验，你会发现自然而然地开发出安全高效的代码就越简单。坚持下去！

当你理解了所有权，你将有坚实的基础来理解这个使 Rust 独一无二的特性。在本章中，你将学习所有权，通过一些专注于一个常见的数据结构string 的例子。

> **栈和堆**
>
> 许多编程语言不需要经常考虑栈和堆。但是在像 Rust 这样的系统编程语言中，一个值在栈上还是堆上会影响语言的行为方式以及为什么你必须做出某些决策。本章后面的章节中，所有权的一部分将根据栈和堆的关系进行描述，因此这里做一个简短的解释以做准备。
>
> 栈和堆都是代码在运行时可以使用的内存部分，但它们的结构方式不同。栈存储值时按获取值的顺序，并按相反的顺序删除值。这就是所谓的后进先出。想象一堆盘子: 当你添加更多盘子时，你把它们放在一堆盘子的上面，当你需要一个盘子时，你从上面拿走一个。从中间或底部增加或删除盘子都不可以！添加数据称为压栈，删除数据称为出栈。存储在栈上的所有数据必须具有已知且固定的大小。在编译时大小未知或大小可能更改的数据必须存储在堆中。
>
> 堆的组织性较差: 当你将数据放到堆上时，请求一定数量的空间。内存分配器在堆中找到一个足够大的空块，将其标记为正在使用，并返回一个指针，该指针是该位置的地址。这个过程称为堆上的分配，有时简称为分配（将值压栈不被认为是分配）。因为指向堆的指针的大小是已知且固定，所以可以将指针存储在栈上，但是当需要实际数据时，必须跟着指针。想象一下坐在餐馆里。当你进入时，你要说明你组中的人数，主人会找到一个适合所有人的空桌子，并将你带到那里。如果你们组里有人来晚了，他们可以问你们坐在哪里从而找到你们。
>
> 压栈比在堆上分配更快，因为分配器永远不必搜索存储新数据的位置; 该位置始终位于栈的顶部。相比之下，在堆上分配空间需要做更多的工作，因为分配器必须首先找到一个足够大的空间来保存数据，然后执行标记，为下一次分配做准备。
>
> 访问堆中的数据比访问栈中的数据慢，因为必须跟随指针才能到达堆中。现代处理器如果在内存中跳转较少，就会更快。继续这个类比，考虑一下餐馆的服务员接受许多桌位的订单。在移动到下一个之前，最有效的方法是在一个表中获得所有订单。从表 A 获取订单，然后从表 B 获取订单，然后再从 A 获取一个订单，然后再从 B 获取一个订单，这将是一个非常缓慢的过程。同样，如果处理器处理的数据靠近其他数据（比如在栈上）而不是更远（比如在堆上） ，那么处理器可以更好地完成工作。
>
> 当你的代码调用一个函数时，传递到函数中的值（可能包括指向堆中数据的指针）和函数的本地变量被压到栈中。当函数结束时，这些值将从栈中弹出。
>
> 跟踪代码的哪些部分正在使用堆上的哪些数据，最小化堆上重复数据的数量，以及清理堆上未使用的数据，这样就不会耗尽空间，这些都是所有权解决的问题。一旦理解了所有权，就不需要经常考虑堆栈和堆，但是知道所有权的主要目的是管理堆上数据可以帮助解释为什么它是这样工作的。

### 所有权规则

首先，让我们看看所有权的规则。当我们通过例子说明这些规则的时候，记住它们：

- 在 Rust 中，每个值都有一个所有者。
- 一次只能有一个所有者。
- 当所有者超出范围，值会被丢弃。

### 变量作用域

现在我们已经了解了 Rust 的基本语法，在例子中，我们将不再包含所有的 `fn main {}` 代码，所以如果你一直跟随下去，请确定手动把以下例子放到一个 `main` 函数中去。作为结果，我们的例子将更加简洁，让我们专注于实际细节，而不是样板代码。

作为所有权的第一个例子，我们将看看一些变量的所有域。作用域是程序中的某一项有效的一个范围。取以下变量：

```rust
let s = "hello;
```

变量 `s` 引用一个字符串字面量，该字符串的值被硬编码到我们程序的文本中。该变量从它被声明的地方开始，直到当前作用域结束都是有效的。Listing 4-1 展示了一个程序，注释说明了变量 `s` 在何处有效。

```rust
    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
}
```

▲ Listing 4-1：变量以及它的有效范围。

换句话说，这里有两个重要的时间点：

- 当 `s` 进入作用域时，是有效的。
- 它保持有效，直接超出作用域。

在这点上，作用域与变量何时有效的关系与其他编程语言类似。现在我们将通过引入 `String` 类型来建立在这个理解的基础上。

### String 类型
